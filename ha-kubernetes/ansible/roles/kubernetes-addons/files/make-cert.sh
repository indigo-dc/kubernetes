#!/bin/bash

# Creates a manifest for a Kubernetes secret from a list of files.
# Each entry in the list must be either a filename, or a secret-key followed by
# the filename. If no secret name is provided "config" is used.
#
# Examples:
#
# #1
#     $0 secret secret.yaml input.txt
#
#  The above invocation will create a manifest for a secret called "secret" in
#  the file "secret.yaml" and have the base64-encoded contents in a key called "config"
# 
# #2
#     $0 secret secret.yaml foo,foo_input.txt bar,bar_input.txt
#
#  The above invocation will create a manifest for a secret called "secret" in
#  the file "secret.yaml" like the previous example. However, it will contain
#  two secret items: one for the key "foo" containing the contents of
#  "foo_input.txt" and one for the key "bar" containing the contents of
#  "bar_input.txt"
# 

USAGE="$0 <secret_name> <output_file> [<secret_key_0>,]<input_file_0> ... [<secret_key_n>,]<input_file_n>"

TECTONIC_NAMESPACE=kube-system

if [ $# -lt 3 ]; then
    echo $USAGE
    exit 1
fi

SECRET_NAME="$1"
SECRET_FILE="$2"
shift 2


cat << EOF > $SECRET_FILE
# ### Generated by generate-secrets-from-file.sh ###
apiVersion: v1
kind: Secret
metadata:
  name: $SECRET_NAME
  namespace: $TECTONIC_NAMESPACE
data:
EOF

for key_file in "$@"; do
    IFS=',' read -ra key_file  <<< "$key_file"
    if [ ${#key_file[@]} -eq "1" ]; then
        key="config"
        file=${key_file[0]}
    else
        key=${key_file[0]}
        file=${key_file[1]}
    fi

    if [ ! -f $file ]; then
		echo "input file $file does not exist" >&2
		exit 1
    fi

    IFS=""
    contents=$(cat $file)
    encoded_contents=$(echo -n $contents | base64 | tr -d '\n')
    echo "  $key: \"$encoded_contents\"" >> $SECRET_FILE
done



